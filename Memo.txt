ABC166
E:(iの式)=(jの式)の形にする。
F:Ctrl+Dで'A'を'B'に変えるとき、"AC"などには適用されないので注意。

ABC165
C:増加列では場合の数はそれほど大きくないことが計算でわかる。
D:まずxがB増えても結果が変わらないことに気づけば、0<=x<=B-1としてよく、第２項を消せる。
E:２数の差（サイクルを超えた側も含む）が重複しないように数列から数字を選んでいけば良いことに気づく。差が大きいペアの内側に、差がそれより2小さいものを入れていけば、数を余らせずにペアを作れる。

ABC162
F:左詰めにした状態を基準に、途中で数回飛ばすことができる。この回数を使ってDPすれば間に合う。実装では端の処理がややこしいが、広めにとっておけば最適解が決まった位置に入る。

ABC161
D:条件を満たす数は、1桁の数から桁を追加しながら再帰的に作れそう。ただし新しく作った数はもともとある数より必ず大きいので、queueを使う。
E:前からの貪欲はすぐわかるので、後ろからの貪欲を発想できるか。

ABC160
E:いらないリンゴは予め捨てればあとは貪欲。簡単にできる部分は削ぎおとした上で問題を考える。

ABC159
E:ビット全探索をエスパーすればあとは貪欲。

ABC156
D:組み合わせ計算nCxでnが大きくxが小さい場合は、nから下にx個の積をx!で割るようにすれば間に合う。ただし先に積を全て取らないと途中で整数にならずずれてしまう。

ABC153
E:桁DP。

ABC152
E:MOD下でlcmを使うとバグる（lcm中の割り算が普通の割り算になっているため）。

ABC151
F:全ての点から半径rの円を書いて共通部分があればよく、それをrに関する二分探索すれば良いことまでは気づけた。この共通部分には必ず2円の交点が含まれていることを利用して絞り込めばOK。

ABC150
F:XORの分配律により、隣接成分のXORを予め取れば良い。いくつずらして一致するかの判定にはKMP法を用いる。

ABC149
E:FFT。FFT後の要素がMODを超える場合（今回は10^5の自乗なので当てはまる）はNTTは使えないっぽい。
または2分探索。今回は直接幸福度の和で回そうとしても各計算ができない。1回の幸福度の下限で回せば良い。

ABC146
E:予め1ずつ引いておけばよい。
F:逆の操作を考える。

ABC145
E:「1つ除く」系は両側の累積計算をする。DPは「〜以下」で持っておく（全マス埋めておく）ほうがよさげ。

ABC144
D:atan2。
E:整数二分探索。0の可能性がある場合はlの初期値を負にしないといけない。

ABC143
E:ワーシャルフロイド法。2回やる。

ABC142
D:具体例を書いて察する。long longを使ったら提出前に必ずチェック！！
E:グラフのノードに、ビットで表した状態を持つ（N<=12で察する）。
F:グラフBFS。最小ループを探す問題に帰着させる。ループの検出には、(a)辺ABを選ぶ (b)BからBFS (c)Aが更新されていれば、ループ　とすればよく、BFSのqueueへの追加と同時に「どの頂点から来たか」を更新していけば、復元もできる（各点への最短ルートの時のみ更新なので、一意に決まる）。変なセグフォが出るときはcinの繰り返し数とかを真っ先に確認しろ。

ABC141
D:priority_queue
E:何をループで回すかを工夫する。今回は重複文字列同士の距離をループするとうまくいく。RollingHashも使える。

ABC140
D:一列系は「変わり目」に着目
E:総和系は、ある要素が何回足されるかに着目。自分より大きい数字だけが重要なので、大きい順に見ていけばよい。multisetを使う。番兵を工夫する。

ABC139
E:まずは愚直にシミュレート。そこから高速化を考える。無理にグラフ化しない。

ABC138
D:木BFS。ループ回数を勘違いすると死ぬ。
E:ベクトルをコピーするときは参照渡ししないとTLEする。

ABC137
D:priority_queue
E:bellman ford

ABC132
E:同じ頂点でも状態が異なる場合、状態数分だけ頂点を複製する。

ABC130
E:似たアルゴリズム(LCS)から考える。足し上げるDPでは重複に気をつける。

ABC129
E:「ある区間でOK/ダメなとき端を延長しても必ずOK/ダメ」みたいなときは尺取り法。

ABC128
E:setを用いる。set用の2分探索を用いる。
構造体ソートを実装。

ABC127
E:マンハッタン距離の縦横分離。
数え上げ順序の入れ替え。
演算はmintを先に（int*mintはダメだがmint*intはOK）

ABC126
F:2^Mまでの2進数のXORは0なので、1つ除いた残りのXORと除いたものは等しくなる。

ABC125
D:複数回の操作をまとめて別の（等価な）操作に置き換えられるか考える。

ABC121
D:XORは結合則が成立。また任意の偶数nについて、nとn+1のXORは1。

ABC120
D:Union_Find。

ABC118
D:DPで複雑なものを持たせない。そうしたい場合は、簡単なものを持たせたDPからの復元を考える。

ABC117
D:最大桁を予め手計算して余裕を持って固定しておくとミスりにくい。
1<<iみたいなのは(ll)1<<iと早めにキャストしておく。(1LL<<iでもOK)。

ABC116
D:とりあえずllを使っとけ。
最適な手順をよく考える。

ABC113
D:mint配列はfillするな。

ABC108
D:構築系。まず特殊な例（この場合Lが2の累乗）を考える。

ABC106
D:2次元累積和。この場合Lが固定されていれば1次元累積和で良いことから類推する。

ABC104:
D:DPにどんな状態を持たせるかをよく考える。

ABC105
D:ライブラリcombinationは暗にMOD=(1e+9)+7を仮定しているので注意。nCkのkが小さければ普通に展開して書いた方がいい。

ABC102
D:どこを固定するかを考える。

ABC095
D:累積和。

ABC092
D:この場合、黒同士が隣接していなければ、白に独立して黒のみ調整できることがわかる。これを黒白同時に行えれば良い。

ABC091
D:XORはビットごとに。
「どこかのビットが立つ」条件は不等式で表せる -> 2分探索
bit=2くらいでの図を書く。

ABC090
D:厄介そうなケースは最初に除く。

ABC087
D:先に全て真と仮定して、それを確かめる方式。
グラフBFS。シンプルに書いてコーナーケースに引っかかるなら追記。

ABC086
D:同値な置き換え。2次元累積和。全パターンを網羅できているかを考える。

ABC083
D:「直前と不変」が続くなら「最初の値とずっと同じ」でいい。
 
ABC082
D:DPでできないかよく考える。
DPテーブルは大きめに取る。

ABC081
D:構築系。まず簡単な例（全て非負）を試してみて、そこに帰着させられるかを考える。今回は操作が2NなのでNの操作2回と察する。構築系はテストケースを参考にしない方がいいかも。

ABC080
D:sとtの条件により、番組表を作る際に最悪でも30*2e+5<1e+7なので間に合う。
imos法なるものがあってO(N+(max_st))だが、今回は同じチャンネルで連続録画する場合にバグるので上のでいい。

ABC079
D:ワーシャルフロイド法。隣接行列が直接書き換わる。

ABC076
D:O(1e+7)を恐れるな。小数出力はprintfでちゃんとやる。

ABC075
D:1e+18*2でllは溢れる。実際のllのmaxはLINF*9あたりなので、適宜書き換える。

ABC074
D:ワーシャルフロイド法に飛びつかない。

ABC073
D:next_permutation、ワーシャルフロイド法。

ABC071
D:組み合わせは、最小パターンをまとめて数えたほうがよい場合がある。今回は縦方向の埋まり方が2通りしか無いので2行まとめてしまうとよい。

ABC070
D:ダイクストラ法。

ABC068
D:構築系。逆の操作を考える。操作の順番が可換な場合、全要素に1回ずつ操作をすれば各要素にとって等価（今回は-1）。

ABC066
D:Modの引き算に注意。

ABC065
D:最小全域木。Kruskal法。

ABC064
D:(vector).size()は非負のみなので、引き算するとヤバイ。「)」が来たときに一番近い「(」とペアにして消せば良いので、stackを使えばOK。

ABC063
D:二分探索。整数の場合のループはwhile(r-l>1)とすればよい。中央の値c=(r-l)/2は、切り捨てとかはあまり気にしなくても大丈夫（必ずr-l=1に収束する）。除算する際は負の数に気をつける。

ABC062
D:+,-の境界についてループすることは気づけたが、その後+と-を別々に処理することに気づけなかった。問題は分けて考えろ。

ABC061
D:ダイクストラ法。単に負閉路が存在するだけではinfの条件にはならないので注意。

ABC060
D:DPと決めつけない。DPの場合は「配る先」が存在することをチェック。

ABC059
D:ゲーム。表を書いてみる。

ABC057
D:二項係数。MODせずにN<=50くらいならパスカルの三角形を用いる。
降順ソートでは型に注意。

ABC054
D:在庫が1なのでナップサックを連想できる。しろ。

ABC051
D:ワーシャルフロイド法。

ABC044
D:うまく絞り込む。今回は b<sqrt(n) は回せて、かつそれ以降は2桁にしかならないことに気付けるか。

ABC038
D:hでソートしてwでLISだと、hが同じものがLIS列に含まれる可能性がある。予めwは降順にしておけば、hがLISしたい列のうちwが同じ部分列は必ず降順であり、ここから2つ以上選ばれることはないのでOK。

ABC037
D:多点BFS。queueに追加する条件を吟味する。
もしくはメモ化再帰

ABC036
D:木DP。帰りがけ順。

ABC035
C:遅延セグ木 or いもす法。
D:ダイクストラ法。単一終点の場合は辺が逆向きのものを考える。グラフが連結と思い込むな。

ABC034
D:二分探索。ある値を境に可不可が決まる場合、二分探索を考える。

ABC032
C:尺取り法。広義単調増加にならない例は初めに除く。

ABC031
D:3bit全探索。

ABC030
D:64bitに収まらない整数の扱い。上の桁から見て行き、「足して10かける」を繰り返す。愚直にシミュレートできるデータを除けば、必ずループに辿り着いているという点も大事。ループに辿り着くまでの操作をループ内に折り返す。

ABC027
C:ゲーム。とりあえず図を書く。
D:見方を変える。遅延セグ木で殴った。

ABC022
C:ワーシャルフロイド法。ループは2つの辺を消せばただのパスになる。

ABC021
D:順番指定されているので、ただの組み合わせになる。

ABC020
C:迷路BFS。回り道がある場合は、queueに追加する条件を「distが更新されたとき」とすればよい。変数名の衝突に注意しろ。

ABC019
D:木の直径。double-sweep。知らなくても直感で試してみる。

ABC018
D:半分全列挙。

ABC017
C:いもす法。

ABC016
D:線分の交差判定。

ABC015
C:K-bit全探索。
D:DP。ループ変数の範囲に注意。dp配列全てを確実に舐めるようにする。

ABC014
C:いもす法。

ABC011
D:doubleなら階乗でもそんなに怖くないが、割れるときには割っとくべき。

ABC010
D:最小カット。Dinic。

ABC007
C:BFS迷路。
D:桁DP（10進）。

ABC006
D:LIS。操作をまとめる。

ABC003
D:包除定理。

------------------------------------------
ARC037
B:木DFSでは有向グラフにしてしまうと1->3<-2みたいになってバグる。よって無向で管理する必要があるが、この場合DFSにnowに加えfromも持っておかないといけない。

ARC006
D:連結部分を数えるBFS。queに多重に追加しないよう気をつける。そのためにはqueに追加した直後にフラグを立てておく（スタート地点はループ前にフラグを立てる）。

ARC005
B:スペース区切りでなくても、char型へだったら勝手に分離してcinしてくれる。
C:01BFS迷路。
------------------------------------------

------------------------------------------
AGC041
B:二分探索で、rはN-1ではなくNにする（試行の際はl+rの平均が使われるため、Nが入ってバグることはない）。rには「必ずfalseになる数」を入れなければならない。

AGC039
A:ループ回数を混同しない。
B:二部グラフの発想。

AGC038
A:構築系。まずは貪欲にできるか試してみる。テストケースに騙されるな。
B:スライド最大・最小はsetを使うとよい。*(set.begin())で最小値、*(set.rbegin())で最大値が得られる。隣り合う範囲が同じ結果になるケースと、元々昇順になっている離れた範囲が同じ結果になるケースの2通りがあり、これらのORを考えるのは面倒なので、UnionFindを使って同じ結果になる範囲同士を連結させればよい。

AGC035
A:ビット演算が絡むときはカッコを多用する。
ex) A^B^C==0 だと C==0 が優先されてしまう。

AGC033
A:BFS迷路（多点スタート）。
B:後ろから考える。勝ち負けの境界位置が毎ターンずれていく。

AGC032
B:サンプルが1つしかない->エスパーできそう->小さいNについて愚直解を書いてみる。

AGC031:
B:DP遷移をよく考える。まずi+1番目の石が区間の右端になるか否かの2通りで、さらに前者には左端候補すべてについての和が必要になるので、累積和が思いつく。

AGC024
B:動かさない方に着目する。位置が重要な問題は、とりあえず各数字の位置を出力してみる。
C:ダメな例を先に除いておけば数えるのは簡単。

AGC023
B:愚直は4乗。これを3乗に落としたい。対称性を考える。

AGC022
A:全文字を使う場合は順列になるのでnext_permutationが使える。

AGC021
A:stoiは頭に0がついていてもOK（例えば"077"->77）。long longにしたければstollを使う。

AGC020:
B:Nから最終人数を求める愚直解を書くと単調性がわかり、二分探索が思いつく。「2以上」と「2以下」で求めれば最小・最大がわかる。

AGC018
B:全部使うところからシミュレーションする。300^3は通る。

AGC014
A:両隣の平均を取っていく操作なので、最大最小の差に着目する。
B:根を考えることで(a,b)を(a,r)と(b,r)に分離できることがポイント。
------------------------------------------
Tenka1 Programmer Contest
C:doubleは使うな。商が整数であることの評価は、intで出した商と割った数の積が割られる数になっていること。
D:2個の組み合わせの列挙はただの2重ループでOK。

CADDi 2018
D:偶奇に着目

第6回 ドワンゴからの挑戦状 予選
B:期待値の問題は、全事象を網羅するので、局所的な確率を考えられる。考える際は確率のまま（分母有りで）考えたほうがよさそう。
今回は各区間について、各スライムが通るか否かを考えるとよい。OEISは最終手段。
C:表の埋め方の問題に帰着させる。
D:最後の方で調整すればよさそうという直感は正しい。よって最後だけ全探索すればよい。小さいものから取りたいがスキップする場合もあるというときは、setを使うと良い。

キーエンス プログラミング コンテスト 2020
B:区間スケジューリング
D:左端から決めていけば偶奇の矛盾を確認しながらできるので、選択ソートを採用する。

第5回 ドワンゴからの挑戦状 予選
B:今回は2分探索できない（達成できるbit積に唯一の境界がないので）。
C:尺取り法。必ずしも右端を伸ばしきったところで精算する必要はない（今回は右端が'C'になった時点でそこまでの"DM"数分ansに加算すればよい）。するとD,M,DMの数が必要になることがわかる。左端を消す際にこれらの値がどう変わるかに注意。

DISCO presents ディスカバリーチャンネル コードコンテスト2020 予選
D:実験により操作の順番が関係ないことを悟る。和を取る際に繰り上がりの有無によって桁数・位和がどう変わるかを考える。

M-SOLUTIONS プロコンオープン
D:各cが何回和に寄与させられるかを考えると、木である条件より結局最大以外のcが1回ずつであることがわかる。またこの過程で、最大のcから順に隣り合うように割り振っていけば良いと気づく。

diverta 2019 Programming Contest 2
C:最終的な符号を先に決める。このとき全部同符号にはできないことを悟る。そうでない場合に必ず構築できることを示せれば、それがそのまま復元手順となる。

CODE FESTIVAL 2016 qual B
C:結ばない辺の数が少なさそうなので、これを全体から引くことを考える。必要な辺は（点の数）-1であることからサンプルで計算すると、ちょうどW*H本の辺を消せばよさそう。さらによく考えると各格子から1辺を引いていけばよい。あとはp,qそれぞれの要素が何回引かれるかを二分探索で求めれば良い。ただしp=qで死なないようにするため、片方はupper_bound、もう片方はlower_boundを使えばよい。
D:サンプルでちゃんと手を動かす。まずPの下限が単調増加することに気づき、さらにあえて大きなPにすることでこの下限の増加を抑制できる場合があるということに気づく。

全国統一プログラミング王決定戦予選
D:トポロジカルソート（DAG）。入次数0のものをansへ->子ノードの入次数を-1する　の繰り返し。今回は子ノードの入次数が0になったタイミングで真の親子関係がわかる。

TDPC
E:桁DP。

CODE FESTIVAL 2017 Final
A:eraseの使い方に注意。vec.erase(vec.begin()+i）みたいにする。
C:50人ではあるが、全状態はもっと少ないので全列挙できる。

日立製作所 社会システム事業部 プログラミングコンテスト2020
C:余事象はMOD3で(1,1)(2,2)のみ。さらに根からのodd,evenが異なるもの同士でしか距離3にはならない。十分条件でよい。