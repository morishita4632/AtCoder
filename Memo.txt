ABC167
F:もともと閉じた括弧を消すと、"))...(("の形になる。この右括弧Rと左括弧Lの数について、-R -> +Lという動きを考えると、0からスタートして負になることなくまた0に戻ってこられればOK。ここで予め各Sについて最終的に増加するか減少するかで分けておけば、ソートの基準が簡潔になる。

ABC166
E:(iの式)=(jの式)の形にする。
F:Ctrl+Dで'A'を'B'に変えるとき、"AC"などには適用されないので注意。

ABC165
C:増加列では場合の数はそれほど大きくないことが計算でわかる。
D:まずxがB増えても結果が変わらないことに気づけば、0<=x<=B-1としてよく、第２項を消せる。
E:２数の差（サイクルを超えた側も含む）が重複しないように数列から数字を選んでいけば良いことに気づく。差が大きいペアの内側に、差がそれより2小さいものを入れていけば、数を余らせずにペアを作れる。
F:DFSの巻き戻しテクニック。stackを使えば良い。LIS。ansは、「最後に更新した点」ではなく「その時点のdpの最後尾までの長さ」なので注意。Lower_bounr(INF)で求まる。

ABC164
E:NやAが小さいので、グラフを拡張して各都市について所持銀貨の数ごとにノードを増幅しても大丈夫。実装時は(都市・銀貨数)をノードに対応させる関数を作ると便利。また銀貨数については0からSmaxまでの(Smax+1)種類の状態が必要なので注意。
F:All 1/0 を埋めた後の残りについて、
・行列共に2以上ならチェック状に埋める
・片方1なら1側のaxisで確定箇所を埋め、残りのaxisでチェック・空き埋めをする
・片方0ならチェック
と場合分けするとわかりやすい。ビットシフトで0/1を取り出すときは b&bit(n)は駄目、(b>>n)&1とする。

ABC163
E:Aの降順に、両端どちらかに詰めていけばよい（ことに気づかないとどうしようもない）。

ABC162
F:左詰めにした状態を基準に、途中で数回飛ばすことができる。この回数を使ってDPすれば間に合う。実装では端の処理がややこしいが、広めにとっておけば最適解が決まった位置に入る。

ABC161
D:条件を満たす数は、1桁の数から桁を追加しながら再帰的に作れそう。ただし新しく作った数はもともとある数より必ず大きいので、queueを使う。
E:前からの貪欲はすぐわかるので、後ろからの貪欲を発想できるか。

ABC160
E:いらないリンゴは予め捨てればあとは貪欲。簡単にできる部分は削ぎおとした上で問題を考える。

ABC159
E:ビット全探索をエスパーすればあとは貪欲。

ABC156
D:組み合わせ計算nCxでnが大きくxが小さい場合は、nから下にx個の積をx!で割るようにすれば間に合う。ただし先に積を全て取らないと途中で整数にならずずれてしまう。

ABC153
E:桁DP。

ABC152
E:MOD下でlcmを使うとバグる（lcm中の割り算が普通の割り算になっているため）。

ABC151
F:全ての点から半径rの円を書いて共通部分があればよく、それをrに関する二分探索すれば良いことまでは気づけた。この共通部分には必ず2円の交点が含まれていることを利用して絞り込めばOK。

ABC150
F:XORの分配律により、隣接成分のXORを予め取れば良い。いくつずらして一致するかの判定にはKMP法を用いる。

ABC149
E:FFT。FFT後の要素がMODを超える場合（今回は10^5の自乗なので当てはまる）はNTTは使えないっぽい。
または2分探索。今回は直接幸福度の和で回そうとしても各計算ができない。1回の幸福度の下限で回せば良い。

ABC146
E:予め1ずつ引いておけばよい。
F:逆の操作を考える。

ABC145
E:「1つ除く」系は両側の累積計算をする。DPは「〜以下」で持っておく（全マス埋めておく）ほうがよさげ。

ABC144
D:atan2。
E:整数二分探索。0の可能性がある場合はlの初期値を負にしないといけない。

ABC143
E:ワーシャルフロイド法。2回やる。

ABC142
D:具体例を書いて察する。long longを使ったら提出前に必ずチェック！！
E:グラフのノードに、ビットで表した状態を持つ（N<=12で察する）。
F:グラフBFS。最小ループを探す問題に帰着させる。ループの検出には、(a)辺ABを選ぶ (b)BからBFS (c)Aが更新されていれば、ループ　とすればよく、BFSのqueueへの追加と同時に「どの頂点から来たか」を更新していけば、復元もできる（各点への最短ルートの時のみ更新なので、一意に決まる）。変なセグフォが出るときはcinの繰り返し数とかを真っ先に確認しろ。

ABC141
D:priority_queue
E:何をループで回すかを工夫する。今回は重複文字列同士の距離をループするとうまくいく。RollingHashも使える。

ABC140
D:一列系は「変わり目」に着目
E:総和系は、ある要素が何回足されるかに着目。自分より大きい数字だけが重要なので、大きい順に見ていけばよい。multisetを使う。番兵を工夫する。

ABC139
E:まずは愚直にシミュレート。そこから高速化を考える。無理にグラフ化しない。

ABC138
D:木BFS。ループ回数を勘違いすると死ぬ。
E:ベクトルをコピーするときは参照渡ししないとTLEする。

ABC137
D:priority_queue
E:bellman ford

ABC132
E:同じ頂点でも状態が異なる場合、状態数分だけ頂点を複製する。

ABC130
E:似たアルゴリズム(LCS)から考える。足し上げるDPでは重複に気をつける。

ABC129
E:「ある区間でOK/ダメなとき端を延長しても必ずOK/ダメ」みたいなときは尺取り法。

ABC128
E:setを用いる。set用の2分探索を用いる。
構造体ソートを実装。

ABC127
E:マンハッタン距離の縦横分離。
数え上げ順序の入れ替え。
演算はmintを先に（int*mintはダメだがmint*intはOK）

ABC126
F:2^Mまでの2進数のXORは0なので、1つ除いた残りのXORと除いたものは等しくなる。

ABC125
D:複数回の操作をまとめて別の（等価な）操作に置き換えられるか考える。

ABC121
D:XORは結合則が成立。また任意の偶数nについて、nとn+1のXORは1。

ABC120
D:Union_Find。

ABC118
D:DPで複雑なものを持たせない。そうしたい場合は、簡単なものを持たせたDPからの復元を考える。

ABC117
D:最大桁を予め手計算して余裕を持って固定しておくとミスりにくい。
1<<iみたいなのは(ll)1<<iと早めにキャストしておく。(1LL<<iでもOK)。

ABC116
D:とりあえずllを使っとけ。
最適な手順をよく考える。

ABC113
D:mint配列はfillするな。

ABC111
D:構築系。マンハッタン距離関係は、(u, v) -> (x+y, x-y) の変換をすると良いかも。パリティーが偶・奇の場合1回ずつはテストする。

ABC108
D:構築系。まず特殊な例（この場合Lが2の累乗）を考える。

ABC106
D:2次元累積和。この場合Lが固定されていれば1次元累積和で良いことから類推する。

ABC104:
D:DPにどんな状態を持たせるかをよく考える。

ABC105
D:ライブラリcombinationは暗にMOD=(1e+9)+7を仮定しているので注意。nCkのkが小さければ普通に展開して書いた方がいい。

ABC102
D:どこを固定するかを考える。

ABC101
D:上限を見定めるのがポイント。直感で、2桁増えたら必ずi/S(i)は大きくなりそうなので、それを利用してすぬけ数を列挙してみる（例えば1e+7まで計算すれば、1e+5までを列挙できる。比較部分は右側累積minでできる）。そのままではわかりにくいが、差を取ってみると10の累乗になることがわかる。最大15桁なのであとは比較するだけ。

ABC095
D:累積和。

ABC093
D:図を書くと、[A,B]の外側はすぐに決まる。x,yの差が1以内ならxy>=(x-z)(y+z)を利用して、[A,B]のうち最も右でかつ差が1以内のペアを探せば、あとはそこから+1, -1していくことで数えられる。

ABC092
D:この場合、黒同士が隣接していなければ、白に独立して黒のみ調整できることがわかる。これを黒白同時に行えれば良い。

ABC091
D:XORはビットごとに。
「どこかのビットが立つ」条件は不等式で表せる -> 2分探索
bit=2くらいでの図を書く。

ABC090
D:厄介そうなケースは最初に除く。

ABC087
D:先に全て真と仮定して、それを確かめる方式。
グラフBFS。シンプルに書いてコーナーケースに引っかかるなら追記。

ABC086
D:同値な置き換え。2次元累積和。全パターンを網羅できているかを考える。

ABC083
D:「直前と不変」が続くなら「最初の値とずっと同じ」でいい。
 
ABC082
D:DPでできないかよく考える。
DPテーブルは大きめに取る。

ABC081
D:構築系。まず簡単な例（全て非負）を試してみて、そこに帰着させられるかを考える。今回は操作が2NなのでNの操作2回と察する。構築系はテストケースを参考にしない方がいいかも。

ABC080
D:sとtの条件により、番組表を作る際に最悪でも30*2e+5<1e+7なので間に合う。
imos法なるものがあってO(N+(max_st))だが、今回は同じチャンネルで連続録画する場合にバグるので上のでいい。

ABC079
D:ワーシャルフロイド法。隣接行列が直接書き換わる。

ABC076
D:O(1e+7)を恐れるな。小数出力はprintfでちゃんとやる。

ABC075
D:1e+18*2でllは溢れる。実際のllのmaxはLINF*9あたりなので、適宜書き換える。

ABC074
D:ワーシャルフロイド法に飛びつかない。

ABC073
D:next_permutation、ワーシャルフロイド法。

ABC071
D:組み合わせは、最小パターンをまとめて数えたほうがよい場合がある。今回は縦方向の埋まり方が2通りしか無いので2行まとめてしまうとよい。

ABC070
D:ダイクストラ法。

ABC068
D:構築系。逆の操作を考える。操作の順番が可換な場合、全要素に1回ずつ操作をすれば各要素にとって等価（今回は-1）。

ABC066
D:Modの引き算に注意。

ABC065
D:最小全域木。Kruskal法。

ABC064
D:(vector).size()は非負のみなので、引き算するとヤバイ。「)」が来たときに一番近い「(」とペアにして消せば良いので、stackを使えばOK。

ABC063
D:二分探索。整数の場合のループはwhile(r-l>1)とすればよい。中央の値c=(r-l)/2は、切り捨てとかはあまり気にしなくても大丈夫（必ずr-l=1に収束する）。除算する際は負の数に気をつける。

ABC062
D:+,-の境界についてループすることは気づけたが、その後+と-を別々に処理することに気づけなかった。問題は分けて考えろ。

ABC061
D:ダイクストラ法。単に負閉路が存在するだけではinfの条件にはならないので注意。

ABC060
D:DPと決めつけない。DPの場合は「配る先」が存在することをチェック。

ABC059
D:ゲーム。表を書いてみる。

ABC057
D:二項係数。MODせずにN<=50くらいならパスカルの三角形を用いる。
降順ソートでは型に注意。

ABC054
D:在庫が1なのでナップサックを連想できる。しろ。

ABC051
D:ワーシャルフロイド法。

ABC044
D:うまく絞り込む。今回は b<sqrt(n) は回せて、かつそれ以降は2桁にしかならないことに気付けるか。

ABC042
D:うまく排反事象に分ける。

ABC041
D:トポロジカルソートの数え上げ。普通にトポロジカルソートをしようとすると、入次数0が複数ある場合に分岐が生じる。これをすべて考慮するためにはbitDPが自然に思いつく。実装時はビット演算&を間違えて&&にしないよう注意。

ABC038
D:hでソートしてwでLISだと、hが同じものがLIS列に含まれる可能性がある。予めwは降順にしておけば、hがLISしたい列のうちwが同じ部分列は必ず降順であり、ここから2つ以上選ばれることはないのでOK。

ABC037
D:多点BFS。queueに追加する条件を吟味する。
もしくはメモ化再帰

ABC036
D:木DP。帰りがけ順。

ABC035
C:遅延セグ木 or いもす法。
D:ダイクストラ法。単一終点の場合は辺が逆向きのものを考える。グラフが連結と思い込むな。

ABC034
D:二分探索。ある値を境に可不可が決まる場合、二分探索を考える。

ABC032
C:尺取り法。広義単調増加にならない例は初めに除く。
D:半分全列挙。

ABC031
D:3bit全探索。

ABC030
D:64bitに収まらない整数の扱い。上の桁から見て行き、「足して10かける」を繰り返す。愚直にシミュレートできるデータを除けば、必ずループに辿り着いているという点も大事。ループに辿り着くまでの操作をループ内に折り返す。

ABC027
C:ゲーム。とりあえず図を書く。
D:見方を変える。遅延セグ木で殴った。

ABC024
D:とりあえず式で書いて試してみる。なるべくmintを使う。

ABC023
C:飴の数<=1e+5に注目。重複を許して数えた後に修正する必要があるのは、交差点に飴がある場合である。よって逆に飴を走査すればよい。
D:負の整数除算はするな。


ABC022
C:ワーシャルフロイド法。ループは2つの辺を消せばただのパスになる。
D:平行移動・回転により変わらない長さに着目する。

ABC021
D:順番指定されているので、ただの組み合わせになる。

ABC020
C:迷路BFS。回り道がある場合は、queueに追加する条件を「distが更新されたとき」とすればよい。変数名の衝突に注意しろ。

ABC019
D:木の直径。double-sweep。知らなくても直感で試してみる。

ABC018
D:半分全列挙。

ABC017
C:いもす法。
D:DP+尺取り法。dp[i]にdp[i-j]を足す部分は、「今日j個食べる」ことと対応する。例えばサンプル1で
 f|   1 2 1 2 2
dp| 1 1 2 3 *
        ↑ ↑
        a b
の*を埋めることを考える。
今日2のアメ1個を食べる場合は、前日までの並びの一番右に追加すれば良いので、bの部分から遷移する。
今日2のアメを昨日の1のアメと合わせて食べる場合は、(1,2)のまとまりを、aの組み合わせの末尾に配置すれば良いので、aから遷移する。
その前日は2のアメなので、今日3個食べることはできない。


ABC016
D:線分の交差判定。

ABC015
C:K-bit全探索。
D:DP。ループ変数の範囲に注意。dp配列全てを確実に舐めるようにする。

ABC014
C:いもす法。
D:LCA。

ABC011
D:doubleなら階乗でもそんなに怖くないが、割れるときには割っとくべき。

ABC010
D:最小カット。Dinic。

ABC009
D:漸化式から行列の繰り返し2乗法を連想する。（XOR, AND）は順に和・積に対応する可換環をなすので行列に載せられる。単位元は順に(0, 11....1)。matmulを非破壊で書いた場合、mat = matmul(A,B)のように書かないといけない。

ABC008
D:分割統治型のメモ化再帰。また座標圧縮も必要だがmapでゴリ押せる。その際に、異なる長方形に対し一意な識別子を与えて比較関数を作らなければならない。これは各値を'_'で結合して文字列化するのが簡単。

ABC007
C:BFS迷路。
D:桁DP（10進）。

ABC006
D:LIS。操作をまとめる。

ABC003
D:包除定理。

------------------------------------------
ARC049
B:共通部分の判定条件をよく考える。doubleのBinSearchは上限回数を決めておいた方が良い。

ARC037
B:木DFSでは有向グラフにしてしまうと1->3<-2みたいになってバグる。よって無向で管理する必要があるが、この場合DFSにnowに加えfromも持っておかないといけない。

ARC028
B:K番目に若い人を取り出したい場合は、逆に年老いた人を取り出すpriority_queueを用意し、常にK人だけ入れておけばよい。

ARC006
D:連結部分を数えるBFS。queに多重に追加しないよう気をつける。そのためにはqueに追加した直後にフラグを立てておく（スタート地点はループ前にフラグを立てる）。

ARC005
B:スペース区切りでなくても、char型へだったら勝手に分離してcinしてくれる。
C:01BFS迷路。
------------------------------------------

------------------------------------------
AGC043
A:予め操作できる系迷路は、一つの経路を固定して考察すると良い。今回は固定した経路に対しては、「連続する壁は1階の操作で消せる」ことがわかる。よって「壁に入る回数」が最小のルートを探せば良く、これはdpで解ける。

AGC041
B:二分探索で、rはN-1ではなくNにする（試行の際はl+rの平均が使われるため、Nが入ってバグることはない）。rには「必ずfalseになる数」を入れなければならない。

AGC039
A:ループ回数を混同しない。
B:二部グラフの発想。

AGC038
A:構築系。まずは貪欲にできるか試してみる。テストケースに騙されるな。
B:スライド最大・最小はsetを使うとよい。*(set.begin())で最小値、*(set.rbegin())で最大値が得られる。隣り合う範囲が同じ結果になるケースと、元々昇順になっている離れた範囲が同じ結果になるケースの2通りがあり、これらのORを考えるのは面倒なので、UnionFindを使って同じ結果になる範囲同士を連結させればよい。

AGC035
A:ビット演算が絡むときはカッコを多用する。
ex) A^B^C==0 だと C==0 が優先されてしまう。

AGC033
A:BFS迷路（多点スタート）。
B:後ろから考える。勝ち負けの境界位置が毎ターンずれていく。

AGC032
B:サンプルが1つしかない->エスパーできそう->小さいNについて愚直解を書いてみる。

AGC031:
B:DP遷移をよく考える。まずi+1番目の石が区間の右端になるか否かの2通りで、さらに前者には左端候補すべてについての和が必要になるので、累積和が思いつく。

AGC024
B:動かさない方に着目する。位置が重要な問題は、とりあえず各数字の位置を出力してみる。
C:ダメな例を先に除いておけば数えるのは簡単。

AGC023
B:愚直は4乗。これを3乗に落としたい。対称性を考える。

AGC022
A:全文字を使う場合は順列になるのでnext_permutationが使える。

AGC021
A:stoiは頭に0がついていてもOK（例えば"077"->77）。long longにしたければstollを使う。

AGC020:
B:Nから最終人数を求める愚直解を書くと単調性がわかり、二分探索が思いつく。「2以上」と「2以下」で求めれば最小・最大がわかる。

AGC018
B:全部使うところからシミュレーションする。300^3は通る。

AGC014
A:両隣の平均を取っていく操作なので、最大最小の差に着目する。
B:根を考えることで(a,b)を(a,r)と(b,r)に分離できることがポイント。
------------------------------------------
Tenka1 Programmer Contest
C:doubleは使うな。商が整数であることの評価は、intで出した商と割った数の積が割られる数になっていること。
D:2個の組み合わせの列挙はただの2重ループでOK。

CADDi 2018
D:偶奇に着目

第6回 ドワンゴからの挑戦状 予選
B:期待値の問題は、全事象を網羅するので、局所的な確率を考えられる。考える際は確率のまま（分母有りで）考えたほうがよさそう。
今回は各区間について、各スライムが通るか否かを考えるとよい。OEISは最終手段。
C:表の埋め方の問題に帰着させる。
D:最後の方で調整すればよさそうという直感は正しい。よって最後だけ全探索すればよい。小さいものから取りたいがスキップする場合もあるというときは、setを使うと良い。

キーエンス プログラミング コンテスト 2020
B:区間スケジューリング
D:左端から決めていけば偶奇の矛盾を確認しながらできるので、選択ソートを採用する。

第5回 ドワンゴからの挑戦状 予選
B:今回は2分探索できない（達成できるbit積に唯一の境界がないので）。
C:尺取り法。必ずしも右端を伸ばしきったところで精算する必要はない（今回は右端が'C'になった時点でそこまでの"DM"数分ansに加算すればよい）。するとD,M,DMの数が必要になることがわかる。左端を消す際にこれらの値がどう変わるかに注意。

DISCO presents ディスカバリーチャンネル コードコンテスト2020 予選
D:実験により操作の順番が関係ないことを悟る。和を取る際に繰り上がりの有無によって桁数・位和がどう変わるかを考える。

M-SOLUTIONS プロコンオープン
D:各cが何回和に寄与させられるかを考えると、木である条件より結局最大以外のcが1回ずつであることがわかる。またこの過程で、最大のcから順に隣り合うように割り振っていけば良いと気づく。

diverta 2019 Programming Contest 2
C:最終的な符号を先に決める。このとき全部同符号にはできないことを悟る。そうでない場合に必ず構築できることを示せれば、それがそのまま復元手順となる。

CODE FESTIVAL 2016 qual B
C:結ばない辺の数が少なさそうなので、これを全体から引くことを考える。必要な辺は（点の数）-1であることからサンプルで計算すると、ちょうどW*H本の辺を消せばよさそう。さらによく考えると各格子から1辺を引いていけばよい。あとはp,qそれぞれの要素が何回引かれるかを二分探索で求めれば良い。ただしp=qで死なないようにするため、片方はupper_bound、もう片方はlower_boundを使えばよい。
D:サンプルでちゃんと手を動かす。まずPの下限が単調増加することに気づき、さらにあえて大きなPにすることでこの下限の増加を抑制できる場合があるということに気づく。

全国統一プログラミング王決定戦予選
D:トポロジカルソート（DAG）。入次数0のものをansへ->子ノードの入次数を-1する　の繰り返し。今回は子ノードの入次数が0になったタイミングで真の親子関係がわかる。

TDPC
E:桁DP。

CODE FESTIVAL 2017 Final
A:eraseの使い方に注意。vec.erase(vec.begin()+i）みたいにする。
C:50人ではあるが、全状態はもっと少ないので全列挙できる。

日立製作所 社会システム事業部 プログラミングコンテスト2020
C:余事象はMOD3で(1,1)(2,2)のみ。さらに根からのodd,evenが異なるもの同士でしか距離3にはならない。十分条件でよい。

PAST01
E:"1 1 1"とかをstringでcinしようとしても"1"で切れるので注意
F:range-based-for文はコピーを作成するので、vectorを書き換えたいときはおとなしくindexを走らせろ。
J:重複があるとめんどそう->図を書く->ある点から3箇所への最短距離問題に帰着しそう->それらがさらに重複する場合でも別の点からの重複なし問題に帰着しそう。交差点のみ３回カウントしているので注意。
K:ライブラリの仕様に注意しろ（当時使っていたLCAライブラリは頂点0が値である前提だった）。
L:ansの型に注意。また関連するtempやライブラリの型にも注意。
M:二分探索で、許容誤差と初期値は毎回確認する。許容誤差を厳しくしすぎるとTLEする。
N:石ごとに見ると、「ここに区間の左端があるとコストがかかる」という位置が決まる。これをimos法で解く。ただし石は開区間で扱うべきなので、座標が重なっている場合はマイナスのイベント->答えの更新->プラスのイベント、の順にやるべき。これはマイナスの直後のみ答えを更新することで実現できる。また門の幅の制限があるが、これは最初は無視しておき、答えを更新する段階でその座標が適切かどうかを判断すればよい。