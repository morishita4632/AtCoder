ABC144
D:atan2。
E:整数二分探索。0の可能性がある場合はlの初期値を負にしないといけない。

ABC143
E:ワーシャルフロイド法。2回やる。

ABC142
D:具体例を書いて察する。long longを使ったら提出前に必ずチェック！！
E:グラフのノードに、ビットで表した状態を持つ（N<=12で察する）。

ABC141
D:priority_queue
E:何をループで回すかを工夫する。今回は重複文字列同士の距離をループするとうまくいく。RollingHashも使える。

ABC140
D:一列系は「変わり目」に着目

ABC139
E:まずは愚直にシミュレート。そこから高速化を考える。無理にグラフ化しない。

ABC138
D:木BFS。ループ回数を勘違いすると死ぬ。
E:ベクトルをコピーするときは参照渡ししないとTLEする。

ABC137
D:priority_queue
E:bellman ford

ABC132
E:同じ頂点でも状態が異なる場合、状態数分だけ頂点を複製する。

ABC130
E:似たアルゴリズム(LCS)から考える。足し上げるDPでは重複に気をつける。

ABC129
E:「ある区間でOK/ダメなとき端を延長しても必ずOK/ダメ」みたいなときは尺取り法。

ABC128
E:setを用いる。set用の2分探索を用いる。
構造体ソートを実装。

ABC127
E:マンハッタン距離の縦横分離。
数え上げ順序の入れ替え。
演算はmintを先に（int*mintはダメだがmint*intはOK）

ABC125
D:複数回の操作をまとめて別の（等価な）操作に置き換えられるか考える。

ABC121
D:XORは結合則が成立。また任意の偶数nについて、nとn+1のXORは1。

ABC120
D:Union_Find。

ABC118
D:DPで複雑なものを持たせない。そうしたい場合は、簡単なものを持たせたDPからの復元を考える。

ABC117
D:最大桁を予め手計算して余裕を持って固定しておくとミスりにくい。
1<<iみたいなのは(ll)1<<iと早めにキャストしておく。(1LL<<iでもOK)。

ABC116
D:とりあえずllを使っとけ。
最適な手順をよく考える。

ABC113
D:mint配列はfillするな。

ABC108
D:構築系。まず特殊な例（この場合Lが2の累乗）を考える。

ABC106
D:2次元累積和。この場合Lが固定されていれば1次元累積和で良いことから類推する。

ABC104:
D:DPにどんな状態を持たせるかをよく考える。

ABC105
D:ライブラリcombinationは暗にMOD=(1e+9)+7を仮定しているので注意。nCkのkが小さければ普通に展開して書いた方がいい。

ABC102
D:どこを固定するかを考える。

ABC095
D:累積和。

ABC092
D:この場合、黒同士が隣接していなければ、白に独立して黒のみ調整できることがわかる。これを黒白同時に行えれば良い。

ABC091
D:XORはビットごとに。
「どこかのビットが立つ」条件は不等式で表せる -> 2分探索
bit=2くらいでの図を書く。

ABC090
D:厄介そうなケースは最初に除く。

ABC087
D:先に全て真と仮定して、それを確かめる方式。
グラフBFS。シンプルに書いてコーナーケースに引っかかるなら追記。

ABC086
D:同値な置き換え。2次元累積和。全パターンを網羅できているかを考える。

ABC083
D:「直前と不変」が続くなら「最初の値とずっと同じ」でいい。
 
ABC082
D:DPでできないかよく考える。
DPテーブルは大きめに取る。

ABC081
D:構築系。まず簡単な例（全て非負）を試してみて、そこに帰着させられるかを考える。今回は操作が2NなのでNの操作2回と察する。構築系はテストケースを参考にしない方がいいかも。

ABC080
D:sとtの条件により、番組表を作る際に最悪でも30*2e+5<1e+7なので間に合う。
imos法なるものがあってO(N+(max_st))だが、今回は同じチャンネルで連続録画する場合にバグるので上のでいい。

ABC079
D:ワーシャルフロイド法。隣接行列が直接書き換わる。

ABC076
D:O(1e+7)を恐れるな。小数出力はprintfでちゃんとやる。

ABC075
D:1e+18*2でllは溢れる。実際のllのmaxはLINF*9あたりなので、適宜書き換える。

ABC074
D:ワーシャルフロイド法に飛びつかない。

ABC073
D:next_permutation、ワーシャルフロイド法。

ABC071
D:組み合わせは、最小パターンをまとめて数えたほうがよい場合がある。今回は縦方向の埋まり方が2通りしか無いので2行まとめてしまうとよい。

ABC070
D:ダイクストラ法。

ABC068
D:構築系。逆の操作を考える。操作の順番が可換な場合、全要素に1回ずつ操作をすれば各要素にとって等価（今回は-1）。

ABC066
D:Modの引き算に注意。

ABC065
D:最小全域木。Kruskal法。

ABC064
D:(vector).size()は非負のみなので、引き算するとヤバイ。「)」が来たときに一番近い「(」とペアにして消せば良いので、stackを使えばOK。

ABC063
D:二分探索。整数の場合のループはwhile(r-l>1)とすればよい。中央の値c=(r-l)/2は、切り捨てとかはあまり気にしなくても大丈夫（必ずr-l=1に収束する）。除算する際は負の数に気をつける。

ABC062
D:+,-の境界についてループすることは気づけたが、その後+と-を別々に処理することに気づけなかった。問題は分けて考えろ。

ABC060
DPと決めつけない。DPの場合は「配る先」が存在することをチェック。

ABC057
D:二項係数。MODせずにN<=50くらいならパスカルの三角形を用いる。
降順ソートでは型に注意。

ABC054
D:在庫が1なのでナップサックを連想できる。しろ。

ABC051
D:ワーシャルフロイド法。

ABC037
D:多点BFS。queueに追加する条件を吟味する。
もしくはメモ化再帰

ABC035
C:遅延セグ木 or いもす法。
D:ダイクストラ法。単一終点の場合は辺が逆向きのものを考える。グラフが連結と思い込むな。

ABC034
D:二分探索。ある値を境に可不可が決まる場合、二分探索を考える。

ABC032
C:尺取り法。広義単調増加にならない例は初めに除く。

ABC031
D:3bit全探索。

ABC030
D:64bitに収まらない整数の扱い。上の桁から見て行き、「足して10かける」を繰り返す。愚直にシミュレートできるデータを除けば、必ずループに辿り着いているという点も大事。ループに辿り着くまでの操作をループ内に折り返す。

ABC027
C:ゲーム。とりあえず図を書く。
D:見方を変える。遅延セグ木で殴った。

ABC022
C:ワーシャルフロイド法。ループは2つの辺を消せばただのパスになる。

ABC020
C:迷路BFS。回り道がある場合は、queueに追加する条件を「distが更新されたとき」とすればよい。変数名の衝突に注意しろ。

ABC019
D:木の直径。double-sweep。知らなくても直感で試してみる。

ABC017
C:いもす法。

ABC016
D:線分の交差判定。

ABC015
C:K-bit全探索。
D:DP。ループ変数の範囲に注意。dp配列全てを確実に舐めるようにする。

ABC014
C:いもす法。

ABC007
C:BFS迷路。
D:桁DP（10進）。

------------------------------------------
ARC006
D:連結部分を数えるBFS。queに多重に追加しないよう気をつける。そのためにはqueに追加した直後にフラグを立てておく（スタート地点はループ前にフラグを立てる）。

ARC005
B:スペース区切りでなくても、char型へだったら勝手に分離してcinしてくれる。
------------------------------------------


------------------------------------------
AGC039
A:ループ回数を混同しない。

AGC038
A:構築系。まずは貪欲にできるか試してみる。テストケースに騙されるな。

AGC035
A:ビット演算が絡むときはカッコを多用する。
ex) A^B^C==0 だと C==0 が優先されてしまう。

AGC033
A:BFS迷路（多点スタート）。

------------------------------------------
Tenka1 Programmer Contest
C:doubleは使うな。商が整数であることの評価は、intで出した商と割った数の積が割られる数になっていること。

------------------------------------------
CADDi 2018
D:偶奇に着目